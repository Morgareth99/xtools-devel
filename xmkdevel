#!/usr/bin/env python3

from typing import List


def checkfile(pkglist: List[str], filelist: str) -> str:
    """ adds vmove declarations to a -devel package function
        pkglist -> List of strings that make up the definition up
        untill 'pkg_install() {'
        filelist -> single string that has all files, separated by newline

        it checks for the presence of a path in filelist for each path defined
        in paths, for each match it appends to pkglist a vmove path statement

        it also detects symlinks by parsing over all lines and checking if one
        contains ' -> ', it then splits it and gets the first half and checks
        if it ends with .so or .la and if matched it adds a glob vmove
        statement

        if no ' -> ' is found it still will check for .a since those aren't
        symlinked

        to complete the string it adds \t} and } and then returns a string
    """

    paths: List[str] = ['usr/include',
                        'usr/lib/pkgconfig',
                        'usr/share/pkgconfig',
                        'usr/lib/cmake',
                        'usr/share/cmake',
                        'usr/share/aclocal',
                        'usr/share/man/man3',
                        'usr/share/info',
                        'usr/share/gtk-doc',
                        'usr/share/gir-1.0',
                        'usr/share/vala']

    for path in paths:
        if path in filelist:
            pkglist.append('\t\tvmove %s' % path)

    if '.so -> ' in filelist:
        pkglist.append('\t\tvmove "usr/lib/*.so"')

    if '.a' in filelist:
        pkglist.append('\t\tvmove "usr/lib/*.a"')

    if '.la' in filelist:
        pkglist.append('\t\tvmove "usr/lib/.la"')

    pkglist.append('\t}')
    pkglist.append('}')

    return '\n'.join(pkglist)


def check_path(prog: str):
    from shutil import which

    if not which(prog):
        print('couldn\'t find %s, install xtools' % prog)
        exit(1)


def make_symlink(srcpkg: str, dstpkg: str, path: str) -> bool:
    from os import chdir, symlink
    from os.path import exists, realpath, islink

    chdir(path)

    if exists(dstpkg):
        if islink(dstpkg) and realpath(dstpkg) == realpath(srcpkg):
            return True
 
        print("Can't make symlink %s exists" % dstpkg)
        return False

    if not exists(srcpkg):
        print("Can't make symlink %s doesn't exist" % srcpkg)
        return False

    symlink(srcpkg, dstpkg)

    if islink(dstpkg) and realpath(dstpkg) == realpath(srcpkg):
        return True

    print("Failed to make symlink to %s" % dstpkg)
    return False


def main():
    for prog in ['xsubpkg', 'xls', 'xdistdir']:
        check_path(prog)

    from argparse import ArgumentParser
    from os.path import isfile
    from subprocess import run, PIPE

    p = ArgumentParser(description="make -devel package functions.")
    p.add_argument('--pkg', dest='pkgname', required=True,
                   help='name of the main package')
    p.add_argument('--dev', dest='devname', nargs='*',
                   help='name of the devel package, with no -devel suffix')
    p.add_argument('--dep', dest='depname',
                   help='name of the dependency of devel package')
    p.add_argument('-i', dest='replace', action='store_true', default=False,
                   help='replace dependencies in template')

    args = p.parse_args()

    """
        we don't require the user to name the -devel package, we just append
        -devel to the name of the package they provided
    """
    if not args.devname:
        args.devname = [args.pkgname + '-devel']
    else:
        args.devname = [s + '-devel' for s in args.devname]

    if not args.depname:
        args.depname = args.pkgname

    """
        Create a path by taking xdistdir and add srcpkgs/ the pkgname and
        /template
    """
    filepath: str = 'srcpkgs/' + args.pkgname + '/template'
    xdistdir = run('xdistdir', stdout=PIPE).stdout.decode('utf-8')
    xdistdir = xdistdir.replace('\n', '/')
    filepath = xdistdir + filepath

    if not isfile(filepath):
        print("Invalid filepath: %s" % filepath)
        exit(2)

    """
        xsubpkg returns the main package and all subpackages of a given name
        we later run it over xls that returns us a newline separated list of
        files
    """
    pkgs = run(['xsubpkg', args.pkgname], stdout=PIPE).stdout.decode('utf-8')

    files: str = ""
    for pkg in pkgs.splitlines():
        files += run(['xls', pkg], stdout=PIPE).stdout.decode('utf-8')

    for devname in args.devname:
        pkglist: List[str] = ['']
        pkglist.append('%s_package() {' % devname)
        pkglist.append('\tshort_desc+=" - development files"')
        pkglist.append('\tdepends="%s-${version}_${revision}"' % args.depname)
        pkglist.append('\tpkg_install() {')

        if args.replace:
            with open(filepath, 'r') as file_in:
                f = file_in.read()

                if f.find(devname + '_package()') != -1:
                    print('package function already defined: %s' % devname)
                    exit(2)

        pkgstring = checkfile(pkglist, files)

        print(pkgstring)

        if args.replace:
            if not make_symlink(args.pkgname, devname, xdistdir + 'srcpkgs'):
                return

            with open(filepath, "a") as file_out:
                file_out.write(pkgstring)


if __name__ == "__main__":
    main()
