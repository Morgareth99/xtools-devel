#!/usr/bin/env python3

from typing import List
from subprocess import run, PIPE
from shutil import which

W = '\033[0m'  # white (normal)
R = '\033[31m'  # red
G = '\033[32m'  # green
O = '\033[33m'  # orange
B = '\033[34m'  # blue
P = '\033[35m'  # purple


def cprint(text: str):
    """ Print text with one specific color """
    print("{}ERROR: {}".format(R, W)+text+W)


def check_path(prog: str):
    """ Checks for :param prog in PATH and exits 1 if not found """

    if not which(prog):
        cprint("couldn't find program {}%s".format(G) % prog)
        exit(1)


def get_filelist(mainpkg: str) -> str:
    """ Uses xsubpkg and xls to get list of packages
    xsubpkg returns the main package and all subpackages of a given name
    we later run it over xls that returns us a newline separated list of
    files """

    (check_path(prog) for prog in ['xsubpkg', 'xls'])

    pkgs = run(['xsubpkg', mainpkg], stdout=PIPE).stdout.decode('utf-8')

    files: str = ""
    for pkg in pkgs.splitlines():
        files += run(['xls', pkg], stdout=PIPE).stdout.decode('utf-8')

    if not files:
        cprint('no files found for pkg {}%s'.format(G) % mainpkg)
        exit(1)

    return files


def doc_checkfile(pkglist: List[str], mainpkg: str) -> List[str]:
    """ add vmove declarations to a -doc package """
    filelist: str = get_filelist(mainpkg)

    if 'usr/share/doc' in filelist:
        append = pkglist.append
        append('\tshort_desc+=" - documentation"')
        append('\tpkg_install() {')
        append('\t\tvmove usr/share/doc')
        return pkglist

    cprint('no files found for pkg {}%s-doc'.format(G) % mainpkg)
    exit(1)


def devel_checkfile(pkglist: List[str], mainpkg: str) -> List[str]:
    """ adds vmove declarations to a -devel package function
        pkglist -> List of strings that make up the definition up
        untill 'pkg_install() {'
        filelist -> single string that has all files, separated by newline

        it checks for the presence of a path in filelist for each path defined
        in paths, for each match it appends to pkglist a vmove path statement

        it also detects symlinks by parsing over all lines and checking if one
        contains ' -> ', it then splits it and gets the first half and checks
        if it ends with .so or .la and if matched it adds a glob vmove
        statement

        if no ' -> ' is found it still will check for .a since those aren't
        symlinked """

    filelist: str = get_filelist(mainpkg)

    append = pkglist.append

    append('\tshort_desc+=" - development files"')
    append('\tpkg_install() {')

    paths: List[str] = ['usr/include',
                        'usr/lib/pkgconfig',
                        'usr/share/pkgconfig',
                        'usr/lib/cmake',
                        'usr/share/cmake',
                        'usr/share/aclocal',
                        'usr/share/man/man3',
                        'usr/share/gtk-doc',
                        'usr/share/gir-1.0',
                        'usr/share/vala']

    for path in paths:
        if path in filelist:
            append('\t\tvmove %s' % path)

    if '.so -> ' in filelist:
        append('\t\tvmove "usr/lib/*.so"')

    if '.a' in filelist:
        append('\t\tvmove "usr/lib/*.a"')

    if '.la' in filelist:
        append('\t\tvmove "usr/lib/.la"')

    return pkglist


def libs_checkfile(pkglist: List[str], mainpkg: str) -> List[str]:
    """ Adds vmove statement for each library found under /usr/lib """

    from re import findall, sub

    append = pkglist.append

    filelist: str = get_filelist(mainpkg)

    """ This removes occourences of library symlinks, those pollute the search
    and are to be used only in -devel packages. """
    filelist = sub(r'.* -> .*\s?', '', filelist)

    matches = findall(r'/usr/lib/.*so.', filelist)

    append('\tshort_desc+=" - libraries"')
    append('\tpkg_install() {')

    for i in matches:
        append('\t\tvmove %s*' % i[1:])

    return pkglist


def checkfile(pkglist: List[str], paths: List[str], desc: str) -> List[str]:
    """ Adds vmove statement for each path in :param paths, this is the
    generic function that is used in case --type isn't set or is set to an
    invalid type """
    append = pkglist.append

    append('\tshort_desc="%s"' % desc)
    append('\tpkg_install() {')

    for path in paths:
        append('\t\tvmove %s' % path)

    return pkglist


def make_symlink(srcpkg: str, dstpkg: str, path: str) -> bool:
    """ creates a symlink for XBPS subpkackages """
    from os import chdir, symlink
    from os.path import exists, realpath, islink, basename

    chdir(path)

    """ if :param srcpkg given to us is a symlink then change it to the
    real one, we don't want to make a symlink to a symlink, all symlinks
    must go to the main package """
    if islink(srcpkg):
        srcpkg = basename(realpath((srcpkg)))

    if exists(dstpkg):
        return islink(dstpkg) and realpath(dstpkg) == realpath(srcpkg)

    symlink(srcpkg, dstpkg)

    return islink(dstpkg) and realpath(dstpkg) == realpath(srcpkg)


def main():
    check_path('xdistdir')

    from argparse import ArgumentParser
    from os.path import isfile

    p = ArgumentParser(description="make xbps-src compliant functions.")
    p.add_argument('--pkg', dest='pkgname', required=True,
                   help='name of the main package')
    p.add_argument('--name', dest='subpkgname', required=True,
                   help='complete name of the subpkg')
    p.add_argument('--deps', dest='depname', nargs='*',
                   help='list of dependencies of the package')
    p.add_argument('--paths', dest='paths', nargs='*',
                   help='list of paths to be included')
    p.add_argument('--desc', dest='shortdesc', nargs='*', default='',
                   help='description for short_desc')
    p.add_argument('-i', dest='replace', action='store_true', default=False,
                   help='replace dependencies in template')

    args = p.parse_args()

    if args.shortdesc:
        args.shortdesc = ' '.join(args.shortdesc)

    """ If provided --name doesn't end with any of the 3 know types then
    cry to the user if no --paths are defined """
    if not any(args.subpkgname.endswith(ext) for ext in ['-doc', '-devel',
                                                         '-libs']):
        if not args.paths:
            cprint("no paths defined with {}--paths".format(G))
            exit(1)

    """
        Create a path by taking xdistdir and add srcpkgs/ the pkgname and
        /template
    """
    filepath: str = 'srcpkgs/' + args.pkgname + '/template'
    xdistdir = run('xdistdir', stdout=PIPE).stdout.decode('utf-8')
    xdistdir = xdistdir.replace('\n', '/')
    filepath = xdistdir + filepath

    if not isfile(filepath):
        cprint("Invalid filepath: {}%s".format(G) % filepath)
        exit(2)

    """ Check early if the function is already matched, this avoids creating
    the string in the first place which is the costlier process """
    if args.replace:
        with open(filepath, 'r') as file_in:
            if file_in.read().find(args.subpkgname + '_package()') != -1:
                cprint("package function {}%s {}already matched".format(G, W)
                       % args.subpkgname)
                exit(2)

    """ Start creating a xbps-src template function
    this creation will certainly go as far as pkg_install, from
    there specific wrappers for certain packages will take place
    or args.paths will be used to determine the pkg_install
    """
    pkglist: List[str] = ['']
    append = pkglist.append
    append('%s_package() {' % args.subpkgname)

    if args.subpkgname.endswith('-doc'):  # -doc only includes noarch files
        append('\tnoarch=yes')

    if args.depname and '-devel' in args.subpkgname:
        append('\tdepends="%s-${version}_${revision} %s"' %
               (args.pkgname, ' '.join(args.depname)))
    elif args.depname:
        append('\tdepends="%s"' % ' '.join(args.depname))

    if args.subpkgname.endswith('-devel'):
        pkglist = devel_checkfile(pkglist, args.pkgname)
    elif args.subpkgname.endswith('-doc'):
        pkglist = doc_checkfile(pkglist, args.pkgname)
    elif args.subpkgname.endswith('-libs'):
        pkglist = libs_checkfile(pkglist, args.pkgname)
    else:
        pkglist = checkfile(pkglist, args.paths, args.shortdesc)

    append('\t}')
    append('}')
    pkgstring = '\n'.join(pkglist)

    print(pkgstring)

    if args.replace:
        if not make_symlink(args.pkgname, args.subpkgname,
                            xdistdir + 'srcpkgs'):
            return

        with open(filepath, "a") as file_out:
            file_out.write(pkgstring)


if __name__ == "__main__":
    main()
